{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "You should buy stock.\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import datetime as dt\n",
    "from nsepy import get_history\n",
    "\n",
    "class HMM(object):\n",
    "    # Implements discrete 1-st order Hidden Markov Model \n",
    "\tdef __init__(self):\n",
    "\t\tpass\n",
    "\n",
    "\tdef forward(self, pi, A, O, observations):\n",
    "\t    N = len(observations)\n",
    "\t    S = len(pi)\n",
    "\t    alpha = np.zeros((N, S))\n",
    "\n",
    "\t    # base case\n",
    "\t    alpha[0, :] = pi * O[:,observations[0]]\n",
    "\t    \n",
    "\t    # recursive case\n",
    "\t    for i in range(1, N):\n",
    "\t        for s2 in range(S):\n",
    "\t            for s1 in range(S):\n",
    "\t                alpha[i, s2] += alpha[i-1, s1] * A[s1, s2] * O[s2, observations[i]]\n",
    "\t    \n",
    "\t    return (alpha, np.sum(alpha[N-1,:]))\n",
    "\n",
    "\tdef backward(self, pi, A, O, observations):\n",
    "\t    N = len(observations)\n",
    "\t    S = len(pi)\n",
    "\t    beta = np.zeros((N, S))\n",
    "\t    \n",
    "\t    # base case\n",
    "\t    beta[N-1, :] = 1\n",
    "\t    \n",
    "\t    # recursive case\n",
    "\t    for i in range(N-2, -1, -1):\n",
    "\t        for s1 in range(S):\n",
    "\t            for s2 in range(S):\n",
    "\t                beta[i, s1] += beta[i+1, s2] * A[s1, s2] * O[s2, observations[i+1]]\n",
    "\t    \n",
    "\t    return (beta, np.sum(pi * O[:, observations[0]] * beta[0,:]))\n",
    "\n",
    "\n",
    "\tdef baum_welch(self, o, N, rand_seed=1):\n",
    "\t    # Implements HMM Baum-Welch algorithm        \n",
    "\t    T = len(o[0])\n",
    "\t    M = int(max(o[0]))+1 # now all hist time-series will contain all observation vals, but we have to provide for all\n",
    "\n",
    "\t    # Initialise A, B and pi randomly, but so that they sum to one\n",
    "\t    np.random.seed(rand_seed)\n",
    "\t        \n",
    "\t    pi_randomizer = np.ndarray.flatten(np.random.dirichlet(np.ones(N),size=1))/100\n",
    "\t    pi=1.0/N*np.ones(N)-pi_randomizer\n",
    "\n",
    "\t    a_randomizer = np.random.dirichlet(np.ones(N),size=N)/100\n",
    "\t    a=1.0/N*np.ones([N,N])-a_randomizer\n",
    "\n",
    "\t    b_randomizer=np.random.dirichlet(np.ones(M),size=N)/100\n",
    "\t    b = 1.0/M*np.ones([N,M])-b_randomizer\n",
    "\n",
    "\t    pi, A, O = np.copy(pi), np.copy(a), np.copy(b) # take copies, as we modify them\n",
    "\t    S = pi.shape[0]\n",
    "\t    iterations = 1000\n",
    "\t    training = o\n",
    "\t    # do several steps of EM hill climbing\n",
    "\t    for it in range(iterations):\n",
    "\t        pi1 = np.zeros_like(pi)\n",
    "\t        A1 = np.zeros_like(A)\n",
    "\t        O1 = np.zeros_like(O)\n",
    "\t        \n",
    "\t        for observations in training:\n",
    "\t            # compute forward-backward matrices\n",
    "\t            alpha, za = self.forward(pi, A, O, observations)\n",
    "\t            beta, zb = self.backward(pi, A, O, observations)\n",
    "\t            assert abs(za - zb) < 1e-6, \"it's badness 10000 if the marginals don't agree\"\n",
    "\t            \n",
    "\t            # M-step here, calculating the frequency of starting state, transitions and (state, obs) pairs\n",
    "\t            pi1 += alpha[0,:] * beta[0,:] / za\n",
    "\t            for i in range(0, len(observations)):\n",
    "\t                O1[:, observations[i]] += alpha[i,:] * beta[i,:] / za\n",
    "\t            for i in range(1, len(observations)):\n",
    "\t                for s1 in range(S):\n",
    "\t                    for s2 in range(S):\n",
    "\t                        A1[s1, s2] += alpha[i-1,s1] * A[s1, s2] * O[s2, observations[i]] * beta[i,s2] / za\n",
    "\t                                                                    \n",
    "\t        # normalise pi1, A1, O1\n",
    "\t        pi = pi1 / np.sum(pi1)\n",
    "\t        for s in range(S):\n",
    "\t            A[s, :] = A1[s, :] / np.sum(A1[s, :])\n",
    "\t            O[s, :] = O1[s, :] / np.sum(O1[s, :])\n",
    "\t    return pi, A, O\n",
    "\n",
    "\tdef predict(self, stock_prices, states=3):\n",
    "\t\t(pi, A, O) = self.baum_welch(np.array([stock_prices]), states)\n",
    "\t\t(alpha, c) = self.forward(pi, A, O, stock_prices)\n",
    "\t\t# normalize alpha\n",
    "\t\trow_sums = alpha.sum(axis=1)\n",
    "\t\tmatrix_1 = alpha / row_sums[:, np.newaxis]\n",
    "\t\t# probability distribution of last hidden state given data\n",
    "\t\tmatrix_2 = matrix_1[-1, :]\n",
    "\t\t# probability distribution of last hidden state given data\n",
    "\t\tmatrix_3 = np.matmul(matrix_2, A)\n",
    "\t\t# probabilty distribution of predicted observation state given past observations\n",
    "\t\tmatrix_4= np.matmul(matrix_3, O)\n",
    "\t\treturn(np.argmax(matrix_4))\n",
    "\n",
    "\tdef get_optimal_states(self, price_movement):\n",
    "\t\taccuracy = 0\n",
    "\t\tfor j in range(2,6):\n",
    "\t\t\tcount=0\n",
    "\t\t\ttotal=0\n",
    "\t\t\tfor i in range(int(3/4*len(price_movement)), len(price_movement)):\n",
    "\t\t\t\ttotal=total+1\n",
    "\t\t\t\tpredicted=self.predict(price_movement[:i], states=j)\n",
    "\t\t\t\tif(predicted==price_movement[i]):\n",
    "\t\t\t\t\tcount=count+1\n",
    "\t\t\taccuracy_this = (count/total*100)\n",
    "\t\t\tif(accuracy_this>accuracy):\n",
    "\t\t\t\taccuracy = accuracy_this\n",
    "\t\t\t\toptimal_states = j\n",
    "\t\treturn j\n",
    "        \n",
    "def get_stock_prices(company_symbol, start_date, end_date):\n",
    "    # stock price data from nsepy library (closing prices)\n",
    "    start_date = dt.datetime.strptime(start_date, '%Y-%m-%d').date()\n",
    "    end_date = dt.datetime.strptime(end_date, '%Y-%m-%d').date()\n",
    "    stock_prices = get_history(symbol=company_symbol, start=start_date, end=end_date)\n",
    "    # pandas dataframe to numpy array\n",
    "    stock_prices = stock_prices.values\n",
    "    # return closing prices\n",
    "    return stock_prices[:,7]\n",
    "        \n",
    "def get_price_movements(stock_prices):\n",
    "\tprice_change = stock_prices[1:] - stock_prices[:-1]\n",
    "\tprice_movement = np.array(list(map((lambda x: 1 if x>0 else 0), price_change)))\n",
    "\treturn price_movement\n",
    "\n",
    "if __name__ == '__main__':\n",
    "\n",
    "    hmm = HMM()\n",
    "    stock_prices = get_stock_prices('SBIN', '2017-01-01', '2017-04-01')\n",
    "    price_movement = get_price_movements(stock_prices)\n",
    "    optimal_states = hmm.get_optimal_states(price_movement)\n",
    "    prediction = hmm.predict(price_movement, optimal_states)\n",
    "    if prediction==1:\n",
    "    \tprint(\"You should buy stock.\")\n",
    "    else:\n",
    "    \tprint(\"Sell stock if you have.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
